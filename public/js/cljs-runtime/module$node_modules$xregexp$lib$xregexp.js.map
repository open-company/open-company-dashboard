{
"version":3,
"file":"module$node_modules$xregexp$lib$xregexp.js",
"lineCount":44,
"mappings":"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",
"sources":["node_modules/xregexp/lib/xregexp.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$xregexp$lib$xregexp\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/parse-int\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\n\nvar _flags = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/flags\"));\n\n/*!\n * XRegExp 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2007-present MIT License\n */\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Property name used for extended regex instance data\nvar REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled\n\nvar features = {\n  astral: false,\n  namespacing: false\n}; // Native methods to use and restore ('native' is an ES3 reserved keyword)\n\nvar nativ = {\n  exec: RegExp.prototype.exec,\n  test: RegExp.prototype.test,\n  match: String.prototype.match,\n  replace: String.prototype.replace,\n  split: String.prototype.split\n}; // Storage for fixed/extended native methods\n\nvar fixed = {}; // Storage for regexes cached by `XRegExp.cache`\n\nvar regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor\n\nvar patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\n\nvar tokens = []; // Token scopes\n\nvar defaultScope = 'default';\nvar classScope = 'class'; // Regexes that match native regex syntax, including octals\n\nvar nativeTokens = {\n  // Any native multicharacter token in default scope, or any single character\n  'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n  // Any native multicharacter token in character class scope, or any single character\n  'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n}; // Any backreference or dollar-prefixed character in replacement strings\n\nvar replacementToken = /\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups\n\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support\n\nvar hasFlagsProp = (0, _flags.default)(/x/) !== undefined; // Shortcut to `Object.prototype.toString`\n\nvar _ref = {},\n    toString = _ref.toString;\n\nfunction hasNativeFlag(flag) {\n  // Can't check based on the presence of properties/getters since browsers might support such\n  // properties even when they don't support the corresponding flag in regex construction (tested\n  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n  // throws an error)\n  var isSupported = true;\n\n  try {\n    // Can't use regex literals for testing even in a `try` because regex literals with\n    // unsupported flags cause a compilation error in IE\n    new RegExp('', flag);\n  } catch (exception) {\n    isSupported = false;\n  }\n\n  return isSupported;\n} // Check for ES6 `u` flag support\n\n\nvar hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support\n\nvar hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags\n\nvar registeredFlags = {\n  g: true,\n  i: true,\n  m: true,\n  u: hasNativeU,\n  y: hasNativeY\n};\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Augmented regex.\n */\n\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n  var _context;\n\n  regex[REGEX_DATA] = {\n    captureNames: captureNames\n  };\n\n  if (isInternalOnly) {\n    return regex;\n  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n\n\n  if (regex.__proto__) {\n    regex.__proto__ = XRegExp.prototype;\n  } else {\n    for (var p in XRegExp.prototype) {\n      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n      // extensions exist on `regex.prototype` anyway\n      regex[p] = XRegExp.prototype[p];\n    }\n  }\n\n  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n\n  regex[REGEX_DATA].flags = xFlags ? (0, _sort.default)(_context = xFlags.split('')).call(_context).join('') : xFlags;\n  return regex;\n}\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {String} String with any duplicate characters removed.\n */\n\n\nfunction clipDuplicates(str) {\n  return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   - `addG` {Boolean} Add flag g while copying the regex.\n *   - `addY` {Boolean} Add flag y while copying the regex.\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\n\n\nfunction copyRegex(regex, options) {\n  var _context2;\n\n  if (!XRegExp.isRegExp(regex)) {\n    throw new TypeError('Type RegExp expected');\n  }\n\n  var xData = regex[REGEX_DATA] || {};\n  var flags = getNativeFlags(regex);\n  var flagsToAdd = '';\n  var flagsToRemove = '';\n  var xregexpSource = null;\n  var xregexpFlags = null;\n  options = options || {};\n\n  if (options.removeG) {\n    flagsToRemove += 'g';\n  }\n\n  if (options.removeY) {\n    flagsToRemove += 'y';\n  }\n\n  if (flagsToRemove) {\n    flags = nativ.replace.call(flags, new RegExp(\"[\".concat(flagsToRemove, \"]+\"), 'g'), '');\n  }\n\n  if (options.addG) {\n    flagsToAdd += 'g';\n  }\n\n  if (options.addY) {\n    flagsToAdd += 'y';\n  }\n\n  if (flagsToAdd) {\n    flags = clipDuplicates(flags + flagsToAdd);\n  }\n\n  if (!options.isInternalOnly) {\n    if (xData.source !== undefined) {\n      xregexpSource = xData.source;\n    } // null or undefined; don't want to add to `flags` if the previous value was null, since\n    // that indicates we're not tracking original precompilation flags\n\n\n    if ((0, _flags.default)(xData) != null) {\n      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n      // removed for non-internal regexes, so don't need to handle it\n      xregexpFlags = flagsToAdd ? clipDuplicates((0, _flags.default)(xData) + flagsToAdd) : (0, _flags.default)(xData);\n    }\n  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n  // translation to native regex syntax\n\n\n  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? (0, _slice.default)(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);\n  return regex;\n}\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {Number}\n */\n\n\nfunction dec(hex) {\n  return (0, _parseInt2.default)(hex, 16);\n}\n/**\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n * inline comment or whitespace with flag x. This is used directly as a token handler function\n * passed to `XRegExp.addToken`.\n *\n * @private\n * @param {String} match Match arg of `XRegExp.addToken` handler\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\n * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.\n */\n\n\nfunction getContextualTokenSeparator(match, scope, flags) {\n  if ( // No need to separate tokens if at the beginning or end of a group\n  match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' || // No need to separate tokens if before or after a `|`\n  match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' || // No need to separate tokens if at the beginning or end of the pattern\n  match.index < 1 || match.index + match[0].length >= match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\n  // The way this is written relies on:\n  // - The search regex matching only 3-char strings.\n  // - Although `substr` gives chars from the end of the string if given a negative index,\n  //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\n  nativ.test.call(/^\\(\\?[:=!]/, match.input.substr(match.index - 3, 3)) || // Avoid separating tokens when the following token is a quantifier\n  isQuantifierNext(match.input, match.index + match[0].length, flags)) {\n    return '';\n  } // Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n  // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n  // error `(? :` into `(?:`.\n\n\n  return '(?:)';\n}\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */\n\n\nfunction getNativeFlags(regex) {\n  return hasFlagsProp ? (0, _flags.default)(regex) : // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n  // with an empty string) allows this to continue working predictably when\n  // `XRegExp.proptotype.toString` is overridden\n  nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {Boolean} Whether the regex uses named capture.\n */\n\n\nfunction hasNamedCapture(regex) {\n  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {String}\n */\n\n\nfunction hex(dec) {\n  return (0, _parseInt2.default)(dec, 10).toString(16);\n}\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n */\n\n\nfunction isQuantifierNext(pattern, pos, flags) {\n  var inlineCommentPattern = '\\\\(\\\\?#[^)]*\\\\)';\n  var lineCommentPattern = '#[^#\\\\n]*';\n  var quantifierPattern = '[?*+]|{\\\\d+(?:,\\\\d*)?}';\n  return nativ.test.call((0, _includes.default)(flags).call(flags, 'x') ? // Ignore any leading whitespace, line comments, and inline comments\n  /^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/ : // Ignore any leading inline comments\n  /^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/, (0, _slice.default)(pattern).call(pattern, pos));\n}\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {Boolean} Whether the object matches the type.\n */\n\n\nfunction isType(value, type) {\n  return toString.call(value) === \"[object \".concat(type, \"]\");\n}\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {String}\n */\n\n\nfunction pad4(str) {\n  while (str.length < 4) {\n    str = \"0\".concat(str);\n  }\n\n  return str;\n}\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {Object} Object with properties `pattern` and `flags`.\n */\n\n\nfunction prepareFlags(pattern, flags) {\n  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n  if (clipDuplicates(flags) !== flags) {\n    throw new SyntaxError(\"Invalid duplicate regex flag \".concat(flags));\n  } // Strip and apply a leading mode modifier with any combination of flags except g or y\n\n\n  pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function ($0, $1) {\n    if (nativ.test.call(/[gy]/, $1)) {\n      throw new SyntaxError(\"Cannot use flag g or y in mode modifier \".concat($0));\n    } // Allow duplicate flags within the mode modifier\n\n\n    flags = clipDuplicates(flags + $1);\n    return '';\n  }); // Throw on unknown native or nonnative flags\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (0, _getIterator2.default)(flags), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var flag = _step.value;\n\n      if (!registeredFlags[flag]) {\n        throw new SyntaxError(\"Unknown regex flag \".concat(flag));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return {\n    pattern: pattern,\n    flags: flags\n  };\n}\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\n\n\nfunction prepareOptions(value) {\n  var options = {};\n\n  if (isType(value, 'String')) {\n    (0, _forEach.default)(XRegExp).call(XRegExp, value, /[^\\s,]+/, function (match) {\n      options[match] = true;\n    });\n    return options;\n  }\n\n  return value;\n}\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\n\n\nfunction registerFlag(flag) {\n  if (!/^[\\w$]$/.test(flag)) {\n    throw new Error('Flag must be a single character A-Za-z0-9_$');\n  }\n\n  registeredFlags[flag] = true;\n}\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\n\n\nfunction runTokens(pattern, flags, pos, scope, context) {\n  var i = tokens.length;\n  var leadChar = pattern[pos];\n  var result = null;\n  var match;\n  var t; // Run in reverse insertion order\n\n  while (i--) {\n    t = tokens[i];\n\n    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !(0, _includes.default)(flags).call(flags, t.flag)) {\n      continue;\n    }\n\n    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n\n    if (match) {\n      result = {\n        matchLength: match[0].length,\n        output: t.handler.call(context, match, scope, flags),\n        reparse: t.reparse\n      }; // Finished with token tests\n\n      break;\n    }\n  }\n\n  return result;\n}\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setAstral(on) {\n  features.astral = on;\n}\n/**\n * Adds named capture groups to the `groups` property of match arrays. See here for details:\n * https://github.com/tc39/proposal-regexp-named-groups\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setNamespacing(on) {\n  features.namespacing = on;\n}\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\n\n\nfunction toObject(value) {\n  // null or undefined\n  if (value == null) {\n    throw new TypeError('Cannot convert null or undefined to object');\n  }\n\n  return value;\n} // ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     - `g` - global\n *     - `i` - ignore case\n *     - `m` - multiline anchors\n *     - `u` - unicode (ES6)\n *     - `y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     - `n` - explicit capture\n *     - `s` - dot matches all (aka singleline)\n *     - `x` - free-spacing and line comments (aka extended)\n *     - `A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n *          (?<month> [0-9]{2} ) -?  # month\n *          (?<day>   [0-9]{2} )     # day`, 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\n\n\nfunction XRegExp(pattern, flags) {\n  if (XRegExp.isRegExp(pattern)) {\n    if (flags !== undefined) {\n      throw new TypeError('Cannot supply flags when copying a RegExp');\n    }\n\n    return copyRegex(pattern);\n  } // Copy the argument behavior of `RegExp`\n\n\n  pattern = pattern === undefined ? '' : String(pattern);\n  flags = flags === undefined ? '' : String(flags);\n\n  if (XRegExp.isInstalled('astral') && !(0, _includes.default)(flags).call(flags, 'A')) {\n    // This causes an error to be thrown if the Unicode Base addon is not available\n    flags += 'A';\n  }\n\n  if (!patternCache[pattern]) {\n    patternCache[pattern] = {};\n  }\n\n  if (!patternCache[pattern][flags]) {\n    var context = {\n      hasNamedCapture: false,\n      captureNames: []\n    };\n    var scope = defaultScope;\n    var output = '';\n    var pos = 0;\n    var result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n\n    var applied = prepareFlags(pattern, flags);\n    var appliedPattern = applied.pattern;\n    var appliedFlags = (0, _flags.default)(applied); // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n    // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n\n    while (pos < appliedPattern.length) {\n      do {\n        // Check for custom tokens at the current position\n        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the\n        // pattern before running tokens again at the same position\n\n        if (result && result.reparse) {\n          appliedPattern = (0, _slice.default)(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice.default)(appliedPattern).call(appliedPattern, pos + result.matchLength);\n        }\n      } while (result && result.reparse);\n\n      if (result) {\n        output += result.output;\n        pos += result.matchLength || 1;\n      } else {\n        // Get the native token at the current position\n        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky'),\n            _XRegExp$exec2 = (0, _slicedToArray2.default)(_XRegExp$exec, 1),\n            token = _XRegExp$exec2[0];\n\n        output += token;\n        pos += token.length;\n\n        if (token === '[' && scope === defaultScope) {\n          scope = classScope;\n        } else if (token === ']' && scope === classScope) {\n          scope = defaultScope;\n        }\n      }\n    }\n\n    patternCache[pattern][flags] = {\n      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n      // groups are sometimes inserted during regex transpilation in order to keep tokens\n      // separated. However, more than one empty group in a row is never needed.\n      pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n      // Strip all but native flags\n      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n      // `context.captureNames` has an item for each capturing group, even if unnamed\n      captures: context.hasNamedCapture ? context.captureNames : null\n    };\n  }\n\n  var generated = patternCache[pattern][flags];\n  return augment(new RegExp(generated.pattern, (0, _flags.default)(generated)), generated.captures, pattern, flags);\n} // Add `RegExp.prototype` to the prototype chain\n\n\nXRegExp.prototype = /(?:)/; // ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\n\nXRegExp.version = '4.3.0'; // ==--------------------------==\n// Public methods\n// ==--------------------------==\n// Intentionally undocumented; used in tests and addons\n\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   - The match array, with named backreference properties.\n *   - The regex scope where the match was found: 'default' or 'class'.\n *   - The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   () => '\\\\x07',\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\n\nXRegExp.addToken = function (regex, handler, options) {\n  options = options || {};\n  var _options = options,\n      optionalFlags = _options.optionalFlags;\n\n  if (options.flag) {\n    registerFlag(options.flag);\n  }\n\n  if (optionalFlags) {\n    optionalFlags = nativ.split.call(optionalFlags, '');\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = (0, _getIterator2.default)(optionalFlags), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var flag = _step2.value;\n        registerFlag(flag);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } // Add to the private list of syntax tokens\n\n\n  tokens.push({\n    regex: copyRegex(regex, {\n      addG: true,\n      addY: hasNativeY,\n      isInternalOnly: true\n    }),\n    handler: handler,\n    scope: options.scope || defaultScope,\n    flag: options.flag,\n    reparse: options.reparse,\n    leadChar: options.leadChar\n  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n  // might now produce different results\n\n  XRegExp.cache.flush('patterns');\n};\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\n\n\nXRegExp.cache = function (pattern, flags) {\n  if (!regexCache[pattern]) {\n    regexCache[pattern] = {};\n  }\n\n  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));\n}; // Intentionally undocumented; used in tests\n\n\nXRegExp.cache.flush = function (cacheName) {\n  if (cacheName === 'patterns') {\n    // Flush the pattern cache used by the `XRegExp` constructor\n    patternCache = {};\n  } else {\n    // Flush the regex cache populated by `XRegExp.cache`\n    regexCache = {};\n  }\n};\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {String} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\n\n\nXRegExp.escape = function (str) {\n  return nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * let pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\n\n\nXRegExp.exec = function (str, regex, pos, sticky) {\n  var cacheKey = 'g';\n  var addY = false;\n  var fakeY = false;\n  var match;\n  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);\n\n  if (addY) {\n    cacheKey += 'y';\n  } else if (sticky) {\n    // Simulate sticky matching by appending an empty capture to the original regex. The\n    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n    // and will not search the rest of the subject string. We'll know that the original regex\n    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n    // capture participated in the match).\n    fakeY = true;\n    cacheKey += 'FakeY';\n  }\n\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: true,\n    addY: addY,\n    source: fakeY ? \"\".concat(regex.source, \"|()\") : undefined,\n    removeY: sticky === false,\n    isInternalOnly: true\n  }));\n  pos = pos || 0;\n  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n\n  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n  // the original regexp failed (see above).\n\n  if (fakeY && match && match.pop() === '') {\n    match = null;\n  }\n\n  if (regex.global) {\n    regex.lastIndex = match ? r2.lastIndex : 0;\n  }\n\n  return match;\n};\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   - The match array, with named backreference properties.\n *   - The zero-based match index.\n *   - The string being traversed.\n *   - The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * const evens = [];\n * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\n\n\nXRegExp.forEach = function (str, regex, callback) {\n  var pos = 0;\n  var i = -1;\n  var match;\n\n  while (match = XRegExp.exec(str, regex, pos)) {\n    // Because `regex` is provided to `callback`, the function could use the deprecated/\n    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n    // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n    // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n    // which is a nice side effect that brings extra safety.\n    callback(match, ++i, str, regex);\n    pos = match.index + (match[0].length || 1);\n  }\n};\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * const globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\n\n\nXRegExp.globalize = function (regex) {\n  return copyRegex(regex, {\n    addG: true\n  });\n};\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // Adds named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral namespacing');\n */\n\n\nXRegExp.install = function (options) {\n  options = prepareOptions(options);\n\n  if (!features.astral && options.astral) {\n    setAstral(true);\n  }\n\n  if (!features.namespacing && options.namespacing) {\n    setNamespacing(true);\n  }\n};\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   - `astral`\n *   - `namespacing`\n * @returns {Boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\n\n\nXRegExp.isInstalled = function (feature) {\n  return !!features[feature];\n};\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {Boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\n\n\nXRegExp.isRegExp = function (value) {\n  return toString.call(value) === '[object RegExp]';\n}; // isType(value, 'RegExp');\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\n\n\nXRegExp.match = function (str, regex, scope) {\n  var global = regex.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: !!global,\n    removeG: scope === 'one',\n    isInternalOnly: true\n  }));\n  var result = nativ.match.call(toObject(str), r2);\n\n  if (regex.global) {\n    regex.lastIndex = scope === 'one' && result ? // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n    result.index + result[0].length : 0;\n  }\n\n  return global ? result || [] : result && result[0];\n};\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\n\n\nXRegExp.matchChain = function (str, chain) {\n  return function recurseChain(values, level) {\n    var item = chain[level].regex ? chain[level] : {\n      regex: chain[level]\n    };\n    var matches = [];\n\n    function addMatch(match) {\n      if (item.backref) {\n        var ERR_UNDEFINED_GROUP = \"Backreference to undefined group: \".concat(item.backref);\n        var isNamedBackref = isNaN(item.backref);\n\n        if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\n          // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\n          if (!(item.backref in match.groups)) {\n            throw new ReferenceError(ERR_UNDEFINED_GROUP);\n          }\n        } else if (!match.hasOwnProperty(item.backref)) {\n          throw new ReferenceError(ERR_UNDEFINED_GROUP);\n        }\n\n        var backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ? match.groups[item.backref] : match[item.backref];\n        matches.push(backrefValue || '');\n      } else {\n        matches.push(match[0]);\n      }\n    }\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = (0, _getIterator2.default)(values), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var value = _step3.value;\n        (0, _forEach.default)(XRegExp).call(XRegExp, value, item.regex, addMatch);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);\n  }([str], 0);\n};\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     - $$ - Inserts a literal $ character.\n *     - $&, $0 - Inserts the matched substring.\n *     - $` - Inserts the string that precedes the matched substring (left context).\n *     - $' - Inserts the string that follows the matched substring (right context).\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     - The zero-based index of the match within the total search string.\n *     - The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\n\n\nXRegExp.replace = function (str, search, replacement, scope) {\n  var isRegex = XRegExp.isRegExp(search);\n  var global = search.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';\n  var s2 = search;\n\n  if (isRegex) {\n    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n    // `lastIndex` isn't updated *during* replacement iterations\n\n    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {\n      addG: !!global,\n      removeG: scope === 'one',\n      isInternalOnly: true\n    }));\n  } else if (global) {\n    s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n  } // Fixed `replace` required for named backreferences, etc.\n\n\n  var result = fixed.replace.call(toObject(str), s2, replacement);\n\n  if (isRegex && search.global) {\n    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n    search.lastIndex = 0;\n  }\n\n  return result;\n};\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}` or\n * `$<name>`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, ($0) => $0.toUpperCase()]\n * ]);\n */\n\n\nXRegExp.replaceEach = function (str, replacements) {\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = (0, _getIterator2.default)(replacements), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var r = _step4.value;\n      str = XRegExp.replace(str, r[0], r[1], r[2]);\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return str;\n};\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\n\n\nXRegExp.split = function (str, separator, limit) {\n  return fixed.split.call(toObject(str), separator, limit);\n};\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n// Do this the easy way :-)\n\n\nXRegExp.test = function (str, regex, pos, sticky) {\n  return !!XRegExp.exec(str, regex, pos, sticky);\n};\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // Don't add named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral namespacing');\n */\n\n\nXRegExp.uninstall = function (options) {\n  options = prepareOptions(options);\n\n  if (features.astral && options.astral) {\n    setAstral(false);\n  }\n\n  if (features.namespacing && options.namespacing) {\n    setNamespacing(false);\n  }\n};\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @param {Object} [options] Options object with optional properties:\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n * // -> /manbearpig/i\n */\n\n\nXRegExp.union = function (patterns, flags, options) {\n  options = options || {};\n  var conjunction = options.conjunction || 'or';\n  var numCaptures = 0;\n  var numPriorCaptures;\n  var captureNames;\n\n  function rewrite(match, paren, backref) {\n    var name = captureNames[numCaptures - numPriorCaptures]; // Capturing group\n\n    if (paren) {\n      ++numCaptures; // If the current capture has a name, preserve the name\n\n      if (name) {\n        return \"(?<\".concat(name, \">\");\n      } // Backreference\n\n    } else if (backref) {\n      // Rewrite the backreference\n      return \"\\\\\".concat(+backref + numPriorCaptures);\n    }\n\n    return match;\n  }\n\n  if (!(isType(patterns, 'Array') && patterns.length)) {\n    throw new TypeError('Must provide a nonempty array of patterns to merge');\n  }\n\n  var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var output = [];\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = (0, _getIterator2.default)(patterns), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var pattern = _step5.value;\n\n      if (XRegExp.isRegExp(pattern)) {\n        numPriorCaptures = numCaptures;\n        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || []; // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n        // independently valid; helps keep this simple. Named captures are put back\n\n        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n      } else {\n        output.push(XRegExp.escape(pattern));\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  var separator = conjunction === 'none' ? '' : '|';\n  return XRegExp(output.join(separator), flags);\n}; // ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\n\n\nfixed.exec = function (str) {\n  var origLastIndex = this.lastIndex;\n  var match = nativ.exec.apply(this, arguments);\n\n  if (match) {\n    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n    // in standards mode follows the spec.\n    if (!correctExecNpcg && match.length > 1 && (0, _includes.default)(match).call(match, '')) {\n      var _context3;\n\n      var r2 = copyRegex(this, {\n        removeG: true,\n        isInternalOnly: true\n      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n      // matching due to characters outside the match\n\n      nativ.replace.call((0, _slice.default)(_context3 = String(str)).call(_context3, match.index), r2, function () {\n        var len = arguments.length; // Skip index 0 and the last 2\n\n        for (var i = 1; i < len - 2; ++i) {\n          if ((i < 0 || arguments.length <= i ? undefined : arguments[i]) === undefined) {\n            match[i] = undefined;\n          }\n        }\n      });\n    } // Attach named capture properties\n\n\n    var groupsObject = match;\n\n    if (XRegExp.isInstalled('namespacing')) {\n      // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n      match.groups = (0, _create.default)(null);\n      groupsObject = match.groups;\n    }\n\n    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n      // Skip index 0\n      for (var i = 1; i < match.length; ++i) {\n        var name = this[REGEX_DATA].captureNames[i - 1];\n\n        if (name) {\n          groupsObject[name] = match[i];\n        }\n      }\n    } // Fix browsers that increment `lastIndex` after zero-length matches\n\n\n    if (this.global && !match[0].length && this.lastIndex > match.index) {\n      this.lastIndex = match.index;\n    }\n  }\n\n  if (!this.global) {\n    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n    this.lastIndex = origLastIndex;\n  }\n\n  return match;\n};\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Boolean} Whether the regex matched the provided value.\n */\n\n\nfixed.test = function (str) {\n  // Do this the easy way :-)\n  return !!fixed.exec.call(this, str);\n};\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\n\n\nfixed.match = function (regex) {\n  if (!XRegExp.isRegExp(regex)) {\n    // Use the native `RegExp` rather than `XRegExp`\n    regex = new RegExp(regex);\n  } else if (regex.global) {\n    var result = nativ.match.apply(this, arguments); // Fixes IE bug\n\n    regex.lastIndex = 0;\n    return result;\n  }\n\n  return fixed.exec.call(regex, toObject(this));\n};\n/**\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n * (`flags`) argument. Use via `XRegExp.replace`.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {String} New string with one or all matches replaced.\n */\n\n\nfixed.replace = function (search, replacement) {\n  var isRegex = XRegExp.isRegExp(search);\n  var origLastIndex;\n  var captureNames;\n  var result;\n\n  if (isRegex) {\n    if (search[REGEX_DATA]) {\n      captureNames = search[REGEX_DATA].captureNames;\n    } // Only needed if `search` is nonglobal\n\n\n    origLastIndex = search.lastIndex;\n  } else {\n    search += ''; // Type-convert\n  } // Don't use `typeof`; some older browsers return 'function' for regex objects\n\n\n  if (isType(replacement, 'Function')) {\n    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n    // functions isn't type-converted to a string\n    result = nativ.replace.call(String(this), search, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (captureNames) {\n        var groupsObject;\n\n        if (XRegExp.isInstalled('namespacing')) {\n          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n          groupsObject = (0, _create.default)(null);\n          args.push(groupsObject);\n        } else {\n          // Change the `args[0]` string primitive to a `String` object that can store\n          // properties. This really does need to use `String` as a constructor\n          args[0] = new String(args[0]);\n          groupsObject = args[0];\n        } // Store named backreferences\n\n\n        for (var i = 0; i < captureNames.length; ++i) {\n          if (captureNames[i]) {\n            groupsObject[captureNames[i]] = args[i + 1];\n          }\n        }\n      } // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n      // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\n\n\n      if (isRegex && search.global) {\n        search.lastIndex = args[args.length - 2] + args[0].length;\n      } // ES6 specs the context for replacement functions as `undefined`\n\n\n      return replacement.apply(void 0, args);\n    });\n  } else {\n    // Ensure that the last value of `args` will be a string when given nonstring `this`,\n    // while still throwing on null or undefined context\n    result = nativ.replace.call(this == null ? this : String(this), search, function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return nativ.replace.call(String(replacement), replacementToken, replacer);\n\n      function replacer($0, bracketed, angled, dollarToken) {\n        bracketed = bracketed || angled; // Named or numbered backreference with curly or angled braces\n\n        if (bracketed) {\n          // XRegExp behavior for `${n}` or `$<n>`:\n          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n          //    entire match. Any number of leading zeros may be used.\n          // 2. Backreference to named capture `n`, if it exists and is not an integer\n          //    overridden by numbered capture. In practice, this does not overlap with\n          //    numbered capture since XRegExp does not allow named capture to use a bare\n          //    integer as the name.\n          // 3. If the name or number does not refer to an existing capturing group, it's\n          //    an error.\n          var n = +bracketed; // Type-convert; drop leading zeros\n\n          if (n <= args.length - 3) {\n            return args[n] || '';\n          } // Groups with the same name is an error, else would need `lastIndexOf`\n\n\n          n = captureNames ? (0, _indexOf.default)(captureNames).call(captureNames, bracketed) : -1;\n\n          if (n < 0) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[n + 1] || '';\n        } // Else, special variable or numbered backreference without curly braces\n\n\n        if (dollarToken === '$') {\n          // $$\n          return '$';\n        }\n\n        if (dollarToken === '&' || +dollarToken === 0) {\n          // $&, $0 (not followed by 1-9), $00\n          return args[0];\n        }\n\n        if (dollarToken === '`') {\n          var _context4;\n\n          // $` (left context)\n          return (0, _slice.default)(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);\n        }\n\n        if (dollarToken === \"'\") {\n          var _context5;\n\n          // $' (right context)\n          return (0, _slice.default)(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);\n        } // Else, numbered backreference without braces\n\n\n        dollarToken = +dollarToken; // Type-convert; drop leading zero\n        // XRegExp behavior for `$n` and `$nn`:\n        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n        // - `$1` is an error if no capturing groups.\n        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n        //   instead.\n        // - `$01` is `$1` if at least one capturing group, else it's an error.\n        // - `$0` (not followed by 1-9) and `$00` are the entire match.\n        // Native behavior, for comparison:\n        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n        // - `$1` is a literal `$1` if no capturing groups.\n        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n        // - `$0` is a literal `$0`.\n\n        if (!isNaN(dollarToken)) {\n          if (dollarToken > args.length - 3) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[dollarToken] || '';\n        } // `$` followed by an unsupported char is an error, unlike native JS\n\n\n        throw new SyntaxError(\"Invalid token \".concat($0));\n      }\n    });\n  }\n\n  if (isRegex) {\n    if (search.global) {\n      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n      search.lastIndex = 0;\n    } else {\n      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n      search.lastIndex = origLastIndex;\n    }\n  }\n\n  return result;\n};\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n */\n\n\nfixed.split = function (separator, limit) {\n  if (!XRegExp.isRegExp(separator)) {\n    // Browsers handle nonregex split correctly, so use the faster native method\n    return nativ.split.apply(this, arguments);\n  }\n\n  var str = String(this);\n  var output = [];\n  var origLastIndex = separator.lastIndex;\n  var lastLastIndex = 0;\n  var lastLength; // Values for `limit`, per the spec:\n  // If undefined: pow(2,32) - 1\n  // If 0, Infinity, or NaN: 0\n  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n  // If negative number: pow(2,32) - floor(abs(limit))\n  // If other: Type-convert, then use the above rules\n  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n\n  limit = (limit === undefined ? -1 : limit) >>> 0;\n  (0, _forEach.default)(XRegExp).call(XRegExp, str, separator, function (match) {\n    // This condition is not the same as `if (match[0].length)`\n    if (match.index + match[0].length > lastLastIndex) {\n      output.push((0, _slice.default)(str).call(str, lastLastIndex, match.index));\n\n      if (match.length > 1 && match.index < str.length) {\n        Array.prototype.push.apply(output, (0, _slice.default)(match).call(match, 1));\n      }\n\n      lastLength = match[0].length;\n      lastLastIndex = match.index + lastLength;\n    }\n  });\n\n  if (lastLastIndex === str.length) {\n    if (!nativ.test.call(separator, '') || lastLength) {\n      output.push('');\n    }\n  } else {\n    output.push((0, _slice.default)(str).call(str, lastLastIndex));\n  }\n\n  separator.lastIndex = origLastIndex;\n  return output.length > limit ? (0, _slice.default)(output).call(output, 0, limit) : output;\n}; // ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\n\n\nXRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/, function (match, scope) {\n  // \\B is allowed in default scope only\n  if (match[1] === 'B' && scope === defaultScope) {\n    return match[0];\n  }\n\n  throw new SyntaxError(\"Invalid escape \".concat(match[0]));\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\n\nXRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/, function (match, scope, flags) {\n  var code = dec(match[1]);\n\n  if (code > 0x10FFFF) {\n    throw new SyntaxError(\"Invalid Unicode code point \".concat(match[0]));\n  }\n\n  if (code <= 0xFFFF) {\n    // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n    // separate from preceding tokens\n    return \"\\\\u\".concat(pad4(hex(code)));\n  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n\n\n  if (hasNativeU && (0, _includes.default)(flags).call(flags, 'u')) {\n    return match[0];\n  }\n\n  throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\n\nXRegExp.addToken(/\\[(\\^?)\\]/, // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n// (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n\n/* eslint-disable no-confusing-arrow */\nfunction (match) {\n  return match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B';\n},\n/* eslint-enable no-confusing-arrow */\n{\n  leadChar: '['\n});\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\n\nXRegExp.addToken(/\\(\\?#[^)]*\\)/, getContextualTokenSeparator, {\n  leadChar: '('\n});\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\n\nXRegExp.addToken(/\\s+|#[^\\n]*\\n?/, getContextualTokenSeparator, {\n  flag: 'x'\n});\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\n\nXRegExp.addToken(/\\./, function () {\n  return '[\\\\s\\\\S]';\n}, {\n  flag: 's',\n  leadChar: '.'\n});\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\n\nXRegExp.addToken(/\\\\k<([\\w$]+)>/, function (match) {\n  var _context6, _context7;\n\n  // Groups with the same name is an error, else would need `lastIndexOf`\n  var index = isNaN(match[1]) ? (0, _indexOf.default)(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];\n  var endIndex = match.index + match[0].length;\n\n  if (!index || index > this.captureNames.length) {\n    throw new SyntaxError(\"Backreference to undefined group \".concat(match[0]));\n  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n  // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n\n\n  return (0, _concat.default)(_context7 = \"\\\\\".concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)');\n}, {\n  leadChar: '\\\\'\n});\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\n\nXRegExp.addToken(/\\\\(\\d+)/, function (match, scope) {\n  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {\n    throw new SyntaxError(\"Cannot use octal escape or backreference to undefined group \".concat(match[0]));\n  }\n\n  return match[0];\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\n\nXRegExp.addToken(/\\(\\?P?<([\\w$]+)>/, function (match) {\n  var _context8;\n\n  // Disallow bare integers as names because named backreferences are added to match arrays\n  // and therefore numeric properties may lead to incorrect lookups\n  if (!isNaN(match[1])) {\n    throw new SyntaxError(\"Cannot use integer as capture name \".concat(match[0]));\n  }\n\n  if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\n    throw new SyntaxError(\"Cannot use reserved word as capture name \".concat(match[0]));\n  }\n\n  if ((0, _includes.default)(_context8 = this.captureNames).call(_context8, match[1])) {\n    throw new SyntaxError(\"Cannot use same name for multiple groups \".concat(match[0]));\n  }\n\n  this.captureNames.push(match[1]);\n  this.hasNamedCapture = true;\n  return '(';\n}, {\n  leadChar: '('\n});\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\n\nXRegExp.addToken(/\\((?!\\?)/, function (match, scope, flags) {\n  if ((0, _includes.default)(flags).call(flags, 'n')) {\n    return '(?:';\n  }\n\n  this.captureNames.push(null);\n  return '(';\n}, {\n  optionalFlags: 'n',\n  leadChar: '('\n});\nvar _default = XRegExp;\nexports.default = _default;\nmodule.exports = exports[\"default\"];\n};"],
"names":["shadow$provide","global","require","module","exports","hasNativeFlag","flag","isSupported","RegExp","exception","augment","regex","captureNames","xSource","xFlags","isInternalOnly","_context","REGEX_DATA","__proto__","XRegExp","prototype","p","source","flags","_sort","default","split","call","join","clipDuplicates","str","nativ","replace","copyRegex","options","_context2","isRegExp","TypeError","xData","hasFlagsProp","_flags","exec","toString","flagsToAdd","flagsToRemove","xregexpSource","xregexpFlags","removeG","removeY","concat","addG","addY","undefined","_slice","dec","hex","_parseInt2","getContextualTokenSeparator","match","scope","test","_includes","pattern","pos","isType","value","type","pad4","length","prepareFlags","SyntaxError","$0","$1","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_getIterator2","_step","next","done","registeredFlags","err","return","prepareOptions","_forEach","registerFlag","Error","toObject","String","isInstalled","patternCache","context","hasNamedCapture","defaultScope","output","applied","appliedPattern","appliedFlags","i","tokens","leadChar","result","t","matchLength","handler","reparse","_XRegExp$exec","nativeTokens","token","_XRegExp$exec2","_slicedToArray2","classScope","captures","generated","_interopRequireDefault","_Object$defineProperty","_concat","_indexOf","_create","features","astral","namespacing","fixed","regexCache","replacementToken","correctExecNpcg","_ref","hasNativeU","hasNativeY","g","m","u","y","version","_clipDuplicates","_hasNativeFlag","_dec","_hex","_pad4","addToken","XRegExp.addToken","optionalFlags","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","push","cache","flush","XRegExp.cache","XRegExp.cache.flush","cacheName","escape","XRegExp.escape","XRegExp.exec","sticky","cacheKey","fakeY","r2","lastIndex","pop","forEach","XRegExp.forEach","callback","index","globalize","XRegExp.globalize","install","XRegExp.install","on","XRegExp.isInstalled","feature","XRegExp.isRegExp","XRegExp.match","matchChain","XRegExp.matchChain","chain","recurseChain","values","level","addMatch","item","backref","ERR_UNDEFINED_GROUP","isNamedBackref","isNaN","groups","ReferenceError","hasOwnProperty","backrefValue","matches","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","XRegExp.replace","search","replacement","isRegex","s2","replaceEach","XRegExp.replaceEach","replacements","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","r","XRegExp.split","separator","limit","XRegExp.test","uninstall","XRegExp.uninstall","union","XRegExp.union","patterns","rewrite","paren","name","numCaptures","numPriorCaptures","conjunction","parts","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","fixed.exec","origLastIndex","apply","arguments","_context3","len","groupsObject","fixed.test","fixed.match","fixed.replace","_len","args","Array","_key","_len2","_key2","replacer","bracketed","angled","dollarToken","n","_context4","_context5","fixed.split","lastLastIndex","lastLength","code","_context6","_context7","endIndex","input","_context8"]
}
