shadow$provide.module$node_modules$xregexp$lib$addons$matchrecursive=function(global$jscomp$0,require,module,exports){global$jscomp$0=require("module$node_modules$$babel$runtime_corejs3$helpers$interopRequireDefault");require("module$node_modules$$babel$runtime_corejs3$core_js_stable$object$define_property")(exports,"__esModule",{value:!0});exports.default=void 0;var _slice=global$jscomp$0(require("module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$slice")),_concat=global$jscomp$0(require("module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$concat")),
_includes=global$jscomp$0(require("module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$includes"));exports.default=function(XRegExp){function row(name,value,start,end){return{name:name,value:value,start:start,end:end}}XRegExp.matchRecursive=function(str,left,right,flags,options){flags=flags||"";options=options||{};var global=(0,_includes.default)(flags).call(flags,"g"),sticky=(0,_includes.default)(flags).call(flags,"y"),basicFlags=flags.replace(/y/g,""),escapeChar=options.escapeChar;
options=options.valueNames;var output=[],openTokens=0,delimStart=0,delimEnd=0,lastOuterEnd=0;left=XRegExp(left,basicFlags);right=XRegExp(right,basicFlags);if(escapeChar){var _context,_context2;if(1<escapeChar.length)throw Error("Cannot use more than one escape character");escapeChar=XRegExp.escape(escapeChar);var esc=new RegExp((0,_concat.default)(_context=(0,_concat.default)(_context2="(?:".concat(escapeChar,"[\\S\\s]|(?:(?!")).call(_context2,XRegExp.union([left,right],"",{conjunction:"or"}).source,
")[^")).call(_context,escapeChar,"])+)+"),flags.replace(/[^imu]+/g,""))}for(;;){escapeChar&&(delimEnd+=(XRegExp.exec(str,esc,delimEnd,"sticky")||[""])[0].length);flags=XRegExp.exec(str,left,delimEnd);basicFlags=XRegExp.exec(str,right,delimEnd);flags&&basicFlags&&(flags.index<=basicFlags.index?basicFlags=null:flags=null);if(flags||basicFlags)delimStart=(flags||basicFlags).index,delimEnd=delimStart+(flags||basicFlags)[0].length;else if(!openTokens)break;if(sticky&&!openTokens&&delimStart>lastOuterEnd)break;
if(flags){if(!openTokens){var outerStart=delimStart;var innerStart=delimEnd}++openTokens}else if(basicFlags&&openTokens){if(!--openTokens&&(options?(options[0]&&outerStart>lastOuterEnd&&output.push(row(options[0],(0,_slice.default)(str).call(str,lastOuterEnd,outerStart),lastOuterEnd,outerStart)),options[1]&&output.push(row(options[1],(0,_slice.default)(str).call(str,outerStart,innerStart),outerStart,innerStart)),options[2]&&output.push(row(options[2],(0,_slice.default)(str).call(str,innerStart,delimStart),
innerStart,delimStart)),options[3]&&output.push(row(options[3],(0,_slice.default)(str).call(str,delimStart,delimEnd),delimStart,delimEnd))):output.push((0,_slice.default)(str).call(str,innerStart,delimStart)),lastOuterEnd=delimEnd,!global))break}else throw Error("Unbalanced delimiter found in string");delimStart===delimEnd&&++delimEnd}global&&!sticky&&options&&options[0]&&str.length>lastOuterEnd&&output.push(row(options[0],(0,_slice.default)(str).call(str,lastOuterEnd),lastOuterEnd,str.length));return output}};
module.exports=exports["default"]}
//# sourceMappingURL=module$node_modules$xregexp$lib$addons$matchrecursive.js.map
