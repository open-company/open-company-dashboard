{"version":3,"sources":["defun/core.cljc"],"mappings":"","names":[],"sourcesContent":["(ns\n    ^{:author \"dennis <killme2008@gmail.com>\"\n      :doc \"A macro to define clojure functions with parameter pattern matching\n            just like erlang or elixir based on core.match. Please see\n            https://github.com/killme2008/defun\"}\n  defun.core\n  (:require #?(:clj [clojure.core.match]\n               :cljs [cljs.core.match :include-macros true])\n            #?@(:clj [[clojure.tools.macro :refer [name-with-attributes]]\n                      [clojure.walk :refer [postwalk]]]))\n  #?(:cljs (:require-macros [defun.core :refer [fun letfun defun defun-]])))\n\n#?(:clj\n   (defmacro if-cljs\n     \"Return then if we are generating cljs code and else for clj code.\n     Source:\n     http://blog.nberger.com.ar/blog/2015/09/18/more-portable-complex-macro-musing/\"\n     [then else]\n     (if (boolean (:ns &env)) then else)))\n\n#?(:clj\n   (defmacro match\n     [& args]\n     `(if-cljs (cljs.core.match/match ~@args)\n               (clojure.core.match/match ~@args))))\n\n#?(:clj\n   (defmacro fun\n     \"Defines a function just like clojure.core/fn with parameter pattern matching\n     See https://github.com/killme2008/defun for details.\"\n     [& sigs]\n     {:forms '[(fun name? [params* ] exprs*) (fun name? ([params* ] exprs*)+)]}\n     (let [name (when (symbol? (first sigs)) (first sigs))\n           sigs (if name (next sigs) sigs)\n           sigs (if (vector? (first sigs))\n                  (list sigs)\n                  (if (seq? (first sigs))\n                    (let [sig-args (map first sigs)]\n                      (if-some [[form] (some #(if-not (vector? %) [%]) sig-args)]\n                        (throw (IllegalArgumentException.\n                                (if (some? form)\n                                  (str \"Parameter declaration \"\n                                       form\n                                       \" should be a vector\")\n                                  (str \"Parameter declaration missing\"))))\n                        sigs))\n                    ;; Assume single arity syntax\n                    (throw (IllegalArgumentException.\n                            (if (seq sigs)\n                              (str \"Parameter declaration \"\n                                   (first sigs)\n                                   \" should be a vector\")\n                              \"Parameter declaration missing\")))))\n           sigs (postwalk\n                 (fn [form]\n                   (if (and (list? form) (= 'recur (first form)))\n                     (list 'recur (cons 'vector (next form)))\n                     form))\n                 sigs)\n           sigs `([& args#]\n                  (match (vec args#)\n                         ~@(mapcat\n                            (fn [[m & more]]\n                              [m (cons 'do more)])\n                            sigs)))]\n       (list* 'fn (if name\n                    (cons name sigs)\n                    sigs)))))\n\n#?(:clj\n   (defmacro letfun\n     \"letfn with parameter pattern matching.\"\n     {:forms '[(letfun [fnspecs*] exprs*)]}\n     [fnspecs & body]\n     `(letfn* ~(vec (interleave (map first fnspecs)\n                                (map #(cons `fun %) fnspecs)))\n              ~@body)))\n\n#?(:clj\n   (defmacro defun\n     \"Define a function just like clojure.core/defn, but using core.match to\n     match parameters. See https://github.com/killme2008/defun for details.\"\n     [name & fdecl]\n     (let [[name body] (name-with-attributes name fdecl)\n           body (if (vector? (first body))\n                  (list body)\n                  body)\n           name (vary-meta name assoc :arglists (list 'quote (@#'clojure.core/sigs body)))]\n       `(def ~name (fun ~@body)))))\n\n#?(:clj\n   (defmacro defun-\n     \"same as defun, yielding non-public def\"\n     [name & decls]\n     (list* `defun (vary-meta name assoc :private true) decls)))\n"]}