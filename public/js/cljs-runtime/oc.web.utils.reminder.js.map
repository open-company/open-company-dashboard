{"version":3,"sources":["oc/web/utils/reminder.cljs"],"mappings":"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","names":["oc.web.utils.reminder/occurrence-values","oc.web.utils.reminder/frequency-values","oc.web.utils.reminder/occurrence-fields","oc.web.utils.reminder/short-assignee-name","assignee","clojure.string/blank?","cljs.core/first","splitted-name","clojure.string.split","has-last-name?","cljs.core.get","cljs.core/second","oc.web.utils.reminder/parse-reminder","reminder-data","js-date","oc.web.lib.utils.js_date","now-year","oc.web.lib.utils/js-date","show-year?","cljs.core.not_EQ_","parsed-date","oc.web.lib.utils.date_string","with-parsed-date","cljs.core.assoc","frequency-kw","cljs.core.keyword","occurrence-field","occurrence-value","occurrence-value-kw","cljs.core.get_in","assignee-map","assignee-name","or__4126__auto__","oc.lib.user.name_for","short-assignee","cljs.core/assoc-in","oc.web.utils.reminder/parse-reminders","reminders-data","parsed-reminders","cljs.core/vec","cljs.core.map","oc.web.utils.reminder/new-reminder-data","org-data","oc.web.dispatcher.org_data","current-user-data","oc.web.dispatcher.current_user_data","cljs.core/select-keys","oc.web.utils.reminder/users-for-reminders","roster-data","fixed-roster","p1__44006#","status","tooltip","G__44009","cljs.core.merge","users-list","p1__44007#","cljs.core._EQ_","oc.web.lib.jwt/user-id","clojure.set/rename-keys","splitted","p1__44008#","cljs.core/group-by","self-user","without-user","cljs.core.concat","cljs.core.sort_by","oc.web.utils.reminder/sort-fn","reminder-a","reminder-b","assignee-compare","cljs.core/compare","oc.web.utils.reminder/sort-reminders","reminders-items","cljs.core.sort","oc.web.utils.reminder/parse-reminders-roster","collection"],"sourcesContent":["(ns oc.web.utils.reminder\n  (:require [clojure.set :refer (rename-keys)]\n            [clojure.string :as s]\n            [oc.web.lib.jwt :as jwt]\n            [oc.lib.user :as user-lib]\n            [oc.web.dispatcher :as dis]\n            [oc.web.lib.utils :as utils]))\n\n(def occurrence-values\n  {:weekly {:monday \"Monday\"\n            :tuesday \"Tuesday\"\n            :wednesday \"Wednesday\"\n            :thursday \"Thursday\"\n            :friday \"Friday\"\n            :saturday \"Saturday\"\n            :sunday \"Sunday\"}\n   :biweekly {:monday \"Monday\"\n              :tuesday \"Tuesday\"\n              :wednesday \"Wednesday\"\n              :thursday \"Thursday\"\n              :friday \"Friday\"\n              :saturday \"Saturday\"\n              :sunday \"Sunday\"}\n   :monthly {:first \"First day of the month\"\n             :first-monday \"First Monday of the month\"\n             :last-friday \"Last Friday of the month\"\n             :last \"Last day of the month\"}\n   :quarterly {:first \"First day of the quarter\"\n               :first-monday \"First Monday of the quarter\"\n               :last-friday \"Last Friday of the quarter\"\n               :last \"Last day of the quarter\"}})\n\n(def frequency-values\n  {:weekly \"Week\"\n   :biweekly \"Two weeks\"\n   :monthly \"Month\"\n   :quarterly \"Quarter\"})\n\n(def occurrence-fields\n  {:weekly :week-occurrence\n   :biweekly :week-occurrence\n   :monthly :period-occurrence\n   :quarterly :period-occurrence})\n\n(defn- short-assignee-name [assignee]\n  (if (and (not (s/blank? (:first-name assignee)))\n           (not (s/blank? (:last-name assignee))))\n    (str (:first-name assignee) \" \" (first (:last-name assignee)) \".\")\n    (let [splitted-name (s/split (:name assignee) #\"\\s\")\n          has-last-name? (not (s/blank? (get splitted-name 1)))]\n      (str (first splitted-name)\n        (when has-last-name?\n          \" \")\n        (when has-last-name?\n          (first (second splitted-name)))\n        (when has-last-name?\n          \".\")))))\n\n(defn parse-reminder\n  \"Given the map of a reminder denormalize it with the assignee and author map.\"\n  [reminder-data]\n  (let [js-date (utils/js-date (:next-send reminder-data))\n        now-year (.getFullYear (utils/js-date))\n        show-year? (not= (.getFullYear js-date) now-year)\n        parsed-date (utils/date-string js-date [:short (when show-year? :year)])\n        with-parsed-date (if (:next-send reminder-data)\n                           (assoc reminder-data :parsed-next-send parsed-date)\n                           reminder-data)\n        frequency-kw (keyword (:frequency reminder-data))\n        occurrence-field (get occurrence-fields frequency-kw)\n        occurrence-value (get reminder-data occurrence-field)\n        occurrence-value-kw (keyword occurrence-value)\n        occurrence-value (get-in occurrence-values [frequency-kw occurrence-value-kw])\n        assignee-map (:assignee reminder-data)\n        assignee-name (or (:name assignee-map) (user-lib/name-for assignee-map))\n        short-assignee (short-assignee-name assignee-map)]\n    (-> with-parsed-date\n      ;; The freuqncy keyword\n      (assoc :frequency frequency-kw)\n      ;; The name of the field used for the occurrence: :week-occurrence or :period-occurrence\n      (assoc :occurrence-label occurrence-field)\n      ;; The occurrence field but in keyword\n      (assoc occurrence-field occurrence-value-kw)\n      ;; The value of the occurrence field like it is visualized, not the keyword for it\n      (assoc :occurrence-value occurrence-value)\n      ;; Make sure assignee has the :name key for sorting\n      (assoc-in [:assignee :name] assignee-name)\n      (assoc-in [:assignee :short-name] short-assignee))))\n\n(defn parse-reminders [reminders-data]\n  (let [parsed-reminders (vec (map parse-reminder (:items reminders-data)))]\n    (assoc reminders-data :items parsed-reminders)))\n\n(defn new-reminder-data []\n  (let [org-data (dis/org-data)\n        current-user-data (dis/current-user-data)]\n    {:headline \"\"\n     :org-uuid (:uuid org-data)\n     :author (select-keys current-user-data [:user-id :avatar-url :name :first-name :last-name])\n     :assignee (select-keys current-user-data [:user-id :avatar-url :name :first-name :last-name])\n     :week-occurrence \"friday\"\n     :frequency \"weekly\"\n     :next-send nil\n     :last-sent nil\n     :assignee-tz (:timezone current-user-data)}))\n\n(defn users-for-reminders [roster-data]\n  (let [fixed-roster (map #(let [status (:status %)\n                                 tooltip (case status\n                                           (\"pending\" \"unverified\") \"This user has an unverified email\"\n                                           nil)]\n                             (merge % {:disabled (not= status \"active\")\n                                       :tooltip tooltip}))\n                      (:items roster-data))\n        users-list (vec (map #(-> %\n                                (assoc :name (str (user-lib/name-for %) (when (= (:user-id %) (jwt/user-id)) \" (you)\")))\n                                (select-keys [:name :user-id :disabled :tooltip])\n                                (rename-keys {:name :label :user-id :value})\n                                (assoc :user-map %))\n                     fixed-roster))\n        splitted (group-by #(= (:value %) (jwt/user-id)) users-list)\n        self-user (-> splitted (get true) first)\n        without-user (get splitted false)]\n    (concat [self-user] (sort-by :label without-user))))\n\n(defn sort-fn [reminder-a reminder-b]\n  (let [assignee-compare (compare (:name (:assignee reminder-a)) (:name (:assignee reminder-b)))]\n    (if (zero? assignee-compare)\n      (compare (:headline reminder-a) (:headline reminder-b))\n      assignee-compare)))\n\n(defn sort-reminders [reminders-items]\n  (sort sort-fn reminders-items))\n\n(defn parse-reminders-roster [roster-data]\n  (let [collection (:collection roster-data)]\n    (assoc collection :users-list (users-for-reminders collection))))"]}