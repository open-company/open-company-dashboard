{
"version":3,
"file":"module$node_modules$scheduler$cjs$scheduler_tracing_development.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/scheduler/cjs/scheduler-tracing.development.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$scheduler$cjs$scheduler_tracing_development\"] = function(global,require,module,exports) {\n/** @license React v0.17.0\n * scheduler-tracing.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n // In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\n\n // To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\n\n // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n // Gather advanced timing metrics for Profiler subtrees.\n\n // Trace which interactions trigger each commit.\n\nvar enableSchedulerTracing = true; // SSR experiments\n\n\n // Only used in www builds.\n\n // Only used in www builds.\n\n // Disable javascript: URL strings in href for XSS protection.\n\n // React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\n\n // These APIs will no longer be \"unstable\" in the upcoming 16.7 release,\n// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.\n\n\n // Experimental React Flare event system and event components support.\n\n // Experimental Host Component support.\n\n // Experimental Scope support.\n\n // New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107\n\n // We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v17?)\n// Till then, we warn about the missing mock, but still fallback to a sync mode compatible version\n\n // For tests, we flush suspense fallbacks in an act scope;\n// *except* in some of our own tests, where we test incremental loading states.\n\n // Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n\n // Part of the simplification of React.createElement so we can eventually move\n// from React.createElement to React.jsx\n// https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md\n\nvar DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\n\nvar interactionIDCounter = 0;\nvar threadIDCounter = 0; // Set of currently traced interactions.\n// Interactions \"stack\"\u2013\n// Meaning that newly traced interactions are appended to the previously active set.\n// When an interaction goes out of scope, the previous set (if any) is restored.\n\nexports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\n\nexports.__subscriberRef = null;\n\nif (enableSchedulerTracing) {\n  exports.__interactionsRef = {\n    current: new Set()\n  };\n  exports.__subscriberRef = {\n    current: null\n  };\n}\n\nfunction unstable_clear(callback) {\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  var prevInteractions = exports.__interactionsRef.current;\n  exports.__interactionsRef.current = new Set();\n\n  try {\n    return callback();\n  } finally {\n    exports.__interactionsRef.current = prevInteractions;\n  }\n}\nfunction unstable_getCurrent() {\n  if (!enableSchedulerTracing) {\n    return null;\n  } else {\n    return exports.__interactionsRef.current;\n  }\n}\nfunction unstable_getThreadID() {\n  return ++threadIDCounter;\n}\nfunction unstable_trace(name, timestamp, callback) {\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  var interaction = {\n    __count: 1,\n    id: interactionIDCounter++,\n    name: name,\n    timestamp: timestamp\n  };\n  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\n  // To do that, clone the current interactions.\n  // The previous set will be restored upon completion.\n\n  var interactions = new Set(prevInteractions);\n  interactions.add(interaction);\n  exports.__interactionsRef.current = interactions;\n  var subscriber = exports.__subscriberRef.current;\n  var returnValue;\n\n  try {\n    if (subscriber !== null) {\n      subscriber.onInteractionTraced(interaction);\n    }\n  } finally {\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkStarted(interactions, threadID);\n      }\n    } finally {\n      try {\n        returnValue = callback();\n      } finally {\n        exports.__interactionsRef.current = prevInteractions;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(interactions, threadID);\n          }\n        } finally {\n          interaction.__count--; // If no async work was scheduled for this interaction,\n          // Notify subscribers that it's completed.\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        }\n      }\n    }\n  }\n\n  return returnValue;\n}\nfunction unstable_wrap(callback) {\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracing) {\n    return callback;\n  }\n\n  var wrappedInteractions = exports.__interactionsRef.current;\n  var subscriber = exports.__subscriberRef.current;\n\n  if (subscriber !== null) {\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\n  } // Update the pending async work count for the current interactions.\n  // Update after calling subscribers in case of error.\n\n\n  wrappedInteractions.forEach(function (interaction) {\n    interaction.__count++;\n  });\n  var hasRun = false;\n\n  function wrapped() {\n    var prevInteractions = exports.__interactionsRef.current;\n    exports.__interactionsRef.current = wrappedInteractions;\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      var returnValue;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback.apply(undefined, arguments);\n        } finally {\n          exports.__interactionsRef.current = prevInteractions;\n\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\n          }\n        }\n      }\n\n      return returnValue;\n    } finally {\n      if (!hasRun) {\n        // We only expect a wrapped function to be executed once,\n        // But in the event that it's executed more than once\u2013\n        // Only decrement the outstanding interaction counts once.\n        hasRun = true; // Update pending async counts for all wrapped interactions.\n        // If this was the last scheduled async work for any of them,\n        // Mark them as completed.\n\n        wrappedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    }\n  }\n\n  wrapped.cancel = function cancel() {\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\n      }\n    } finally {\n      // Update pending async counts for all wrapped interactions.\n      // If this was the last scheduled async work for any of them,\n      // Mark them as completed.\n      wrappedInteractions.forEach(function (interaction) {\n        interaction.__count--;\n\n        if (subscriber && interaction.__count === 0) {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        }\n      });\n    }\n  };\n\n  return wrapped;\n}\n\nvar subscribers = null;\n\nif (enableSchedulerTracing) {\n  subscribers = new Set();\n}\n\nfunction unstable_subscribe(subscriber) {\n  if (enableSchedulerTracing) {\n    subscribers.add(subscriber);\n\n    if (subscribers.size === 1) {\n      exports.__subscriberRef.current = {\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n        onInteractionTraced: onInteractionTraced,\n        onWorkCanceled: onWorkCanceled,\n        onWorkScheduled: onWorkScheduled,\n        onWorkStarted: onWorkStarted,\n        onWorkStopped: onWorkStopped\n      };\n    }\n  }\n}\nfunction unstable_unsubscribe(subscriber) {\n  if (enableSchedulerTracing) {\n    subscribers.delete(subscriber);\n\n    if (subscribers.size === 0) {\n      exports.__subscriberRef.current = null;\n    }\n  }\n}\n\nfunction onInteractionTraced(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionTraced(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onInteractionScheduledWorkCompleted(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkScheduled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkScheduled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStarted(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStarted(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStopped(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStopped(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkCanceled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkCanceled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nexports.unstable_clear = unstable_clear;\nexports.unstable_getCurrent = unstable_getCurrent;\nexports.unstable_getThreadID = unstable_getThreadID;\nexports.unstable_trace = unstable_trace;\nexports.unstable_wrap = unstable_wrap;\nexports.unstable_subscribe = unstable_subscribe;\nexports.unstable_unsubscribe = unstable_unsubscribe;\n  })();\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","onInteractionTraced","interaction","didCatchError","caughtError","subscribers","forEach","subscriber","error","onInteractionScheduledWorkCompleted","onWorkScheduled","interactions","threadID","onWorkStarted","onWorkStopped","onWorkCanceled","Object","defineProperty","value","interactionIDCounter","threadIDCounter","__interactionsRef","__subscriberRef","current","Set","unstable_clear","callback","prevInteractions","unstable_getCurrent","unstable_getThreadID","unstable_trace","name","timestamp","arguments","length","undefined","DEFAULT_THREAD_ID","__count","id","add","returnValue","unstable_wrap","wrapped","wrappedInteractions","apply","hasRun","cancel","wrapped.cancel","unstable_subscribe","size","unstable_unsubscribe","delete"]
}
