{
"version":3,
"file":"module$node_modules$$sentry$core$dist$request.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAe,6CAAf,CAAkE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAC1GC,MAAA,CAAOC,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CACA,KAAIC,QAAUN,OAAA,CAAQ,8CAAR,CAgCdE,QAAA,CAAQK,oBAAR,CA9BAA,QAA6B,CAACC,KAAD,CAAQC,GAAR,CAAa,CACtC,IAAIC,YAA6B,aAA7BA,GAAcF,KAAdE,CAAoBC,IACpBC,IAAAA,CAAM,CACNC,KAAMC,IAAA,CAAKC,SAAL,CAAeP,KAAf,CADA,CAENQ,IAAKN,WAAA,CAAcD,GAAA,CAAIQ,qCAAJ,EAAd,CAA4DR,GAAA,CAAIS,kCAAJ,EAF3D,CASNR,YAAJ,GACQS,WAcJ,CAdsBL,IAAA,CAAKC,SAAL,CAAe,CACjCK,SAAUZ,KAAVY,CAAgBA,QADiB;AAIjCC,QAAS,CAAA,IAAIC,IAAJ,CAAqC,GAArC,CAAShB,OAAA,CAAQiB,eAAR,EAAT,CAAA,EAA2CC,WAA3C,EAJwB,CAAf,CActB,CARIC,KAQJ,CARkBX,IAAA,CAAKC,SAAL,CAAe,CAC7BJ,KAAMH,KAANG,CAAYA,IADiB,CAAf,CAQlB,CAAAC,GAAA,CAAIC,IAAJ,CADeM,WACf,CADiC,IACjC,CADwCM,KACxC,CADsD,IACtD,CAD6Db,GAC7D,CADiEC,IAdrE,CAiBA,OAAOD,IA5B+B,CAJgE;",
"sources":["node_modules/@sentry/core/dist/request.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$sentry$core$dist$request\"] = function(global,require,module,exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"@sentry/utils\");\n/** Creates a SentryRequest from an event. */\nfunction eventToSentryRequest(event, api) {\n    var useEnvelope = event.type === 'transaction';\n    var req = {\n        body: JSON.stringify(event),\n        url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth(),\n    };\n    // https://develop.sentry.dev/sdk/envelopes/\n    // Since we don't need to manipulate envelopes nor store them, there is no\n    // exported concept of an Envelope with operations including serialization and\n    // deserialization. Instead, we only implement a minimal subset of the spec to\n    // serialize events inline here.\n    if (useEnvelope) {\n        var envelopeHeaders = JSON.stringify({\n            event_id: event.event_id,\n            // We need to add * 1000 since we divide it by 1000 by default but JS works with ms precision\n            // The reason we use timestampWithMs here is that all clocks across the SDK use the same clock\n            sent_at: new Date(utils_1.timestampWithMs() * 1000).toISOString(),\n        });\n        var itemHeaders = JSON.stringify({\n            type: event.type,\n        });\n        // The trailing newline is optional. We intentionally don't send it to avoid\n        // sending unnecessary bytes.\n        //\n        // const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}\\n`;\n        var envelope = envelopeHeaders + \"\\n\" + itemHeaders + \"\\n\" + req.body;\n        req.body = envelope;\n    }\n    return req;\n}\nexports.eventToSentryRequest = eventToSentryRequest;\n//# sourceMappingURL=request.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","utils_1","eventToSentryRequest","event","api","useEnvelope","type","req","body","JSON","stringify","url","getEnvelopeEndpointWithUrlEncodedAuth","getStoreEndpointWithUrlEncodedAuth","envelopeHeaders","event_id","sent_at","Date","timestampWithMs","toISOString","itemHeaders"]
}
