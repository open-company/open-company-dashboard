{
"version":3,
"file":"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/react-virtualized/dist/commonjs/Grid/utils/CellSizeAndPositionManager.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _types = require('../types');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Just-in-time calculates and caches size and position information for a collection of cells.\n */\n\nvar CellSizeAndPositionManager = function () {\n\n  // Used in deferred mode to track which cells have been queued for measurement.\n\n  // Cache of size and position data for cells, mapped by cell index.\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\n  function CellSizeAndPositionManager(_ref) {\n    var cellCount = _ref.cellCount,\n        cellSizeGetter = _ref.cellSizeGetter,\n        estimatedCellSize = _ref.estimatedCellSize;\n    (0, _classCallCheck3.default)(this, CellSizeAndPositionManager);\n    this._cellSizeAndPositionData = {};\n    this._lastMeasuredIndex = -1;\n    this._lastBatchedIndex = -1;\n\n    this._cellSizeGetter = cellSizeGetter;\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n  }\n\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\n\n\n  (0, _createClass3.default)(CellSizeAndPositionManager, [{\n    key: 'areOffsetsAdjusted',\n    value: function areOffsetsAdjusted() {\n      return false;\n    }\n  }, {\n    key: 'configure',\n    value: function configure(_ref2) {\n      var cellCount = _ref2.cellCount,\n          estimatedCellSize = _ref2.estimatedCellSize,\n          cellSizeGetter = _ref2.cellSizeGetter;\n\n      this._cellCount = cellCount;\n      this._estimatedCellSize = estimatedCellSize;\n      this._cellSizeGetter = cellSizeGetter;\n    }\n  }, {\n    key: 'getCellCount',\n    value: function getCellCount() {\n      return this._cellCount;\n    }\n  }, {\n    key: 'getEstimatedCellSize',\n    value: function getEstimatedCellSize() {\n      return this._estimatedCellSize;\n    }\n  }, {\n    key: 'getLastMeasuredIndex',\n    value: function getLastMeasuredIndex() {\n      return this._lastMeasuredIndex;\n    }\n  }, {\n    key: 'getOffsetAdjustment',\n    value: function getOffsetAdjustment() {\n      return 0;\n    }\n\n    /**\n     * This method returns the size and position for the cell at the specified index.\n     * It just-in-time calculates (or used cached values) for cells leading up to the index.\n     */\n\n  }, {\n    key: 'getSizeAndPositionOfCell',\n    value: function getSizeAndPositionOfCell(index) {\n      if (index < 0 || index >= this._cellCount) {\n        throw Error('Requested index ' + index + ' is outside of range 0..' + this._cellCount);\n      }\n\n      if (index > this._lastMeasuredIndex) {\n        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n        var _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\n\n        for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n          var _size = this._cellSizeGetter({ index: i });\n\n          // undefined or NaN probably means a logic error in the size getter.\n          // null means we're using CellMeasurer and haven't yet measured a given index.\n          if (_size === undefined || isNaN(_size)) {\n            throw Error('Invalid size returned for cell ' + i + ' of value ' + _size);\n          } else if (_size === null) {\n            this._cellSizeAndPositionData[i] = {\n              offset: _offset,\n              size: 0\n            };\n\n            this._lastBatchedIndex = index;\n          } else {\n            this._cellSizeAndPositionData[i] = {\n              offset: _offset,\n              size: _size\n            };\n\n            _offset += _size;\n\n            this._lastMeasuredIndex = index;\n          }\n        }\n      }\n\n      return this._cellSizeAndPositionData[index];\n    }\n  }, {\n    key: 'getSizeAndPositionOfLastMeasuredCell',\n    value: function getSizeAndPositionOfLastMeasuredCell() {\n      return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {\n        offset: 0,\n        size: 0\n      };\n    }\n\n    /**\n     * Total size of all cells being measured.\n     * This value will be completely estimated initially.\n     * As cells are measured, the estimate will be updated.\n     */\n\n  }, {\n    key: 'getTotalSize',\n    value: function getTotalSize() {\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n      var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\n      var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;\n      var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;\n      return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;\n    }\n\n    /**\n     * Determines a new offset that ensures a certain cell is visible, given the current offset.\n     * If the cell is already visible then the current offset will be returned.\n     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\n     *\n     * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @param currentOffset Container's current (x or y) offset\n     * @param totalSize Total size (width or height) of all cells\n     * @return Offset to use to ensure the specified cell is visible\n     */\n\n  }, {\n    key: 'getUpdatedOffsetForIndex',\n    value: function getUpdatedOffsetForIndex(_ref3) {\n      var _ref3$align = _ref3.align,\n          align = _ref3$align === undefined ? 'auto' : _ref3$align,\n          containerSize = _ref3.containerSize,\n          currentOffset = _ref3.currentOffset,\n          targetIndex = _ref3.targetIndex;\n\n      if (containerSize <= 0) {\n        return 0;\n      }\n\n      var datum = this.getSizeAndPositionOfCell(targetIndex);\n      var maxOffset = datum.offset;\n      var minOffset = maxOffset - containerSize + datum.size;\n\n      var idealOffset = void 0;\n\n      switch (align) {\n        case 'start':\n          idealOffset = maxOffset;\n          break;\n        case 'end':\n          idealOffset = minOffset;\n          break;\n        case 'center':\n          idealOffset = maxOffset - (containerSize - datum.size) / 2;\n          break;\n        default:\n          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n          break;\n      }\n\n      var totalSize = this.getTotalSize();\n\n      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    }\n  }, {\n    key: 'getVisibleCellRange',\n    value: function getVisibleCellRange(params) {\n      var containerSize = params.containerSize,\n          offset = params.offset;\n\n\n      var totalSize = this.getTotalSize();\n\n      if (totalSize === 0) {\n        return {};\n      }\n\n      var maxOffset = offset + containerSize;\n      var start = this._findNearestCell(offset);\n\n      var datum = this.getSizeAndPositionOfCell(start);\n      offset = datum.offset + datum.size;\n\n      var stop = start;\n\n      while (offset < maxOffset && stop < this._cellCount - 1) {\n        stop++;\n\n        offset += this.getSizeAndPositionOfCell(stop).size;\n      }\n\n      return {\n        start: start,\n        stop: stop\n      };\n    }\n\n    /**\n     * Clear all cached values for cells after the specified index.\n     * This method should be called for any cell that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\n     */\n\n  }, {\n    key: 'resetCell',\n    value: function resetCell(index) {\n      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n    }\n  }, {\n    key: '_binarySearch',\n    value: function _binarySearch(high, low, offset) {\n      while (low <= high) {\n        var middle = low + Math.floor((high - low) / 2);\n        var _currentOffset = this.getSizeAndPositionOfCell(middle).offset;\n\n        if (_currentOffset === offset) {\n          return middle;\n        } else if (_currentOffset < offset) {\n          low = middle + 1;\n        } else if (_currentOffset > offset) {\n          high = middle - 1;\n        }\n      }\n\n      if (low > 0) {\n        return low - 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: '_exponentialSearch',\n    value: function _exponentialSearch(index, offset) {\n      var interval = 1;\n\n      while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {\n        index += interval;\n        interval *= 2;\n      }\n\n      return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);\n    }\n\n    /**\n     * Searches for the cell (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest cell index will be returned.\n     * This allows partially visible cells (with offsets just before/above the fold) to be visible.\n     */\n\n  }, {\n    key: '_findNearestCell',\n    value: function _findNearestCell(offset) {\n      if (isNaN(offset)) {\n        throw Error('Invalid offset ' + offset + ' specified');\n      }\n\n      // Our search algorithms find the nearest match at or below the specified offset.\n      // So make sure the offset is at least 0 or no match will be found.\n      offset = Math.max(0, offset);\n\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n      var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n      if (lastMeasuredCellSizeAndPosition.offset >= offset) {\n        // If we've already measured cells within this range just use a binary search as it's faster.\n        return this._binarySearch(lastMeasuredIndex, 0, offset);\n      } else {\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n        // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.\n        // The overall complexity for this approach is O(log n).\n        return this._exponentialSearch(lastMeasuredIndex, offset);\n      }\n    }\n  }]);\n  return CellSizeAndPositionManager;\n}();\n\nexports.default = CellSizeAndPositionManager;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","_classCallCheck3","_classCallCheck2","__esModule","default","_createClass3","_createClass2","CellSizeAndPositionManager","_ref","cellCount","cellSizeGetter","estimatedCellSize","_cellSizeAndPositionData","_lastBatchedIndex","_lastMeasuredIndex","_cellSizeGetter","_cellCount","_estimatedCellSize","key","areOffsetsAdjusted","configure","_ref2","getCellCount","getEstimatedCellSize","getLastMeasuredIndex","getOffsetAdjustment","getSizeAndPositionOfCell","index","Error","lastMeasuredCellSizeAndPosition","getSizeAndPositionOfLastMeasuredCell","_offset","offset","size","i","_size","undefined","isNaN","getTotalSize","getUpdatedOffsetForIndex","_ref3","_ref3$align","align","containerSize","currentOffset","datum","targetIndex","maxOffset","minOffset","idealOffset","Math","max","min","totalSize","getVisibleCellRange","params","start","_findNearestCell","stop","resetCell","_binarySearch","high","low","middle","floor","_currentOffset","_exponentialSearch","interval","lastMeasuredIndex"]
}
